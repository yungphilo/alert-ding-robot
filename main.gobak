package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/prometheus/alertmanager/template"

	"gopkg.in/yaml.v2"
)

// 配置文件结构
type Config struct {
	PrometheusURL   string        `yaml:"prometheus_url"`
	DingTalkWebhook string        `yaml:"dingtalk_webhook"`
	Alerts          []AlertConfig `yaml:"alerts"`
}

// 告警配置结构
type AlertConfig struct {
	Metric     string        `yaml:"metric"`
	PodPrefix  string        `yaml:"pod_prefix"`
	AtUserList []string      `yaml:"at_user_list"`
	Threshold  float64       `yaml:"threshold"`
	Window     time.Duration `yaml:"window"`
	For        time.Duration `yaml:"for"`
	Every      time.Duration `yaml:"every"`
}

// 钉钉消息结构
type DingTalkMessage struct {
	MsgType string              `yaml:"msgtype"`
	Text    map[string]string   `yaml:"text"`
	At      map[string][]string `yaml:"at"`
}

func main() {
	// 加载配置文件
	cfg, err := loadConfig("config.yaml")
	if err != nil {
		fmt.Printf("Failed to load config file: %s\n", err.Error())
		return
	}

	// 创建Prometheus客户端
	client := http.Client{
		Timeout: 5 * time.Second,
	}

	// 定时获取告警信息
	for {
		for _, alertCfg := range cfg.Alerts {
			// 构造PromQL查询表达式
			query := fmt.Sprintf("sum(%s) > %f", alertCfg.Metric, alertCfg.Threshold)

			// 添加时间窗口限制
			if alertCfg.Window > 0 {
				query += fmt.Sprintf(`[%ds]`, int64(alertCfg.Window.Seconds()))
			}

			// 添加持续时间限制
			if alertCfg.For > 0 {
				query += fmt.Sprintf(` for %ds`, int64(alertCfg.For.Seconds()))
			}

			// 添加轮询间隔限制
			if alertCfg.Every > 0 {
				query += fmt.Sprintf(` every %ds`, int64(alertCfg.Every.Seconds()))
			}

			// 查询Prometheus指标数据
			metrics, err := queryPrometheus(&client, cfg.PrometheusURL, query)
			if err != nil {
				fmt.Printf("Failed to query Prometheus: %s\n", err.Error())
				continue
			}

			// 处理告警信息
			for podPrefix, atUserList := range map[string][]string{alertCfg.PodPrefix: alertCfg.AtUserList} {
				pattern := `^%s.*`
				if strings.HasSuffix(podPrefix, "-") {
					pattern = `%s.*`
				}

				for _, metric := range metrics {
					if strings.HasPrefix(metric.Instance, fmt.Sprintf(pattern, podPrefix)) {
						// 发送钉钉消息
						err := sendDingTalkMessage(cfg.DingTalkWebhook, fmt.Sprintf("Metric %s exceeded threshold: %f", alertCfg.Metric, metric.Value), atUserList)
						if err != nil {
							fmt.Printf("Failed to send DingTalk message: %s\n", err.Error())
						}
					}
				}
			}
		}

		// 每隔5分钟轮询一次
		time.Sleep(5 * time.Minute)
	}
}

// 加载配置文件
func loadConfig(filename string) (*Config, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var cfg Config
	err = yaml.Unmarshal(data, &cfg)
	if err != nil {
		return nil, err
	}

	return &cfg, nil
}

// 查询Prometheus指标数据
func queryPrometheus(client *http.Client, url string, query string) ([]Metric, error) {
	queryURL := fmt.Sprintf("%s/api/v1/query?query=%s", url, query)

	req, err := http.NewRequest(http.MethodGet, queryURL, nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Status string `json:"status"`
		Data   struct {
			Result []struct {
				Metric map[string]string `json:"metric"`
				Value  []interface{}     `json:"value"`
			} `json:"result"`
		} `json:"data"`
	}

	err = json.NewDecoder(resp.Body).Decode(&result)
	if err != nil {
		return nil, err
	}

	var metrics []Metric

	for _, r := range result.Data.Result {
		if len(r.Value) == 2 {
			f, ok := r.Value[1].(float64)
			if !ok {
				continue
			}

			metrics = append(metrics, Metric{
				Instance: r.Metric["instance"],
				Value:    f,
			})
		}
	}

	return metrics, nil
}

// 发送钉钉消息
func sendDingTalkMessage(webhookURL string, message string, atUserList []string) error {
	// 构造钉钉消息内容
	dingTalkMsg := DingTalkMessage{
		MsgType: "text",
		Text: map[string]string{
			"content": message,
		},
		At: map[string][]string{
			"atMobiles": atUserList,
		},
	}

	// 将消息内容转为JSON
	msgData, err := json.Marshal(dingTalkMsg)
	if err != nil {
		return err
	}

	// 发送HTTP POST请求
	resp, err := http.Post(webhookURL, "application/json", strings.NewReader(string(msgData)))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// 检查响应状态码
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected response status code: %d", resp.StatusCode)
	}

	return nil
}

// Prometheus指标结构
type Metric struct {
	Instance string
	Value    float64
}

// 实现Prometheus告警接口
func (m Metric) Labels() template.Labels {
	return template.KV("instance", m.Instance)
}

func (m Metric) Annotations() template.Annotations {
	return template.KV("value", fmt.Sprintf("%.2f", m.Value))
}

func (m Metric) StartsAt() time.Time {
	return time.Now()
}

func (m Metric) EndsAt() time.Time {
	return time.Time{}
}

func (m Metric) Fingerprint() string {
	return fmt.Sprintf("%s:%f", m.Instance, m.Value)
}

func (m Metric) String() string {
	return fmt.Sprintf("%s = %.2f", m.Instance, m.Value)
}

func (m Metric) Description() string {
	return ""
}

func (m Metric) Runbook() string {
	return ""
}

func (m Metric) Summary() string {
	return ""
}

func (m Metric) ValueString() string {
	return fmt.Sprintf("%.2f", m.Value)
}

func (m Metric) ResolvedLabels() template.HTML {
	return nil
}

func (m Metric) ResolvedAnnotations() template.Annotations {
	return nil
}

func (m Metric) ResolvedStartsAt() time.Time {
	return time.Time{}
}

func (m Metric) ResolvedEndsAt() time.Time {
	return time.Time{}
}

func (m Metric) GetExtra() interface{} {
	return nil
}

func (m Metric) Context(ctx context.Context) context.Context {
	return ctx
}
